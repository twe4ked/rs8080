use std::env;
use std::fmt;
use std::fs::File;
use std::io::prelude::*;

struct State {
    b: u8,
    pc: u16,
    sp: u16,
    memory: [u8; 0x10000], // 16k
}

impl fmt::Debug for State {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:04x} b: {:02x}, sp: {:02x}", self.pc, self.b, self.sp)
    }
}

fn disassemble_1(instruction: &'static str) -> u16 {
    println!("\t{instruction}", instruction = instruction);
    1
}

fn disassemble_2(instruction: &'static str, byte_1: u8) -> u16 {
    println!("{byte_1:02x}\t{instruction}\t${byte_1:02x}", instruction = instruction, byte_1 = byte_1);
    2
}

fn disassemble_3(instruction: &'static str, byte_1: u8, byte_2: u8) -> u16 {
    println!("{byte_1:02x} {byte_2:02x}\t{instruction}\t${byte_2:02x}{byte_1:02x}", instruction = instruction, byte_1 = byte_1, byte_2 = byte_2);
    3
}

fn disassemble_not_implemented() -> u16 {
    println!("\t???");
    0
}

#[allow(dead_code)]
fn disassemble(pc: u16, state: &State) -> u16 {
    let pc = pc as usize;
    let byte_1 = state.memory[pc];
    let byte_2 = *state.memory.get(pc + 1).unwrap_or(&0);
    let byte_3 = *state.memory.get(pc + 2).unwrap_or(&0);

    print!("{:04x} {:02x} ", pc, byte_1);

    let op_bytes = match byte_1 {
        0x00 => { disassemble_1("NOP") },
        0x01 => { disassemble_3("LXI B", byte_2, byte_3) },
        0x02 => { disassemble_1("STAX B") },
        0x03 => { disassemble_1("INX B") },
        0x04 => { disassemble_1("INR B") },
        0x05 => { disassemble_1("DCR B") },
        0x06 => { disassemble_2("MVI B", byte_2) },
        0x07 => { disassemble_1("RLC") },
        0x08 => { disassemble_1("-") },
        0x09 => { disassemble_1("DAD B") },
        0x0a => { disassemble_1("LDAX B") },
        0x0b => { disassemble_1("DCX B") },
        0x0c => { disassemble_1("INR C") },
        0x0d => { disassemble_1("DCR C") },
        0x0e => { disassemble_2("MVI C", byte_2) },
        0x0f => { disassemble_1("RRC") },
        0x10 => { disassemble_1("-") },
        0x11 => { disassemble_3("LXI D", byte_2, byte_3) },
        0x12 => { disassemble_1("STAX D") },
        0x13 => { disassemble_1("INX D") },
        0x14 => { disassemble_1("INR D") },
        0x15 => { disassemble_1("DCR D") },
        0x16 => { disassemble_2("MVI D", byte_2) },
        0x17 => { disassemble_not_implemented() },
        0x18 => { disassemble_1("-") },
        0x19 => { disassemble_1("DAD D") },
        0x1a => { disassemble_1("LDAX D") },
        0x1b => { disassemble_1("DCX D") },
        0x1c => { disassemble_1("INR E") },
        0x1d => { disassemble_1("DCR E") },
        0x1e => { disassemble_2("MVI E", byte_2) },
        0x1f => { disassemble_1("RAR") },
        0x20 => { disassemble_1("RIM") },
        0x21 => { disassemble_3("LXI H", byte_2, byte_3) },
        0x22 => { disassemble_3("SHLD", byte_2, byte_3) },
        0x23 => { disassemble_1("INX H") },
        0x24 => { disassemble_1("INR H") },
        0x25 => { disassemble_1("DCR H") },
        0x26 => { disassemble_2("MVI H", byte_2) },
        0x27 => { disassemble_1("DAA") },
        0x28 => { disassemble_1("-") },
        0x29 => { disassemble_1("DAD H") },
        0x2a => { disassemble_3("LHLD", byte_2, byte_3) },
        0x2b => { disassemble_1("DCX H") },
        0x2c => { disassemble_1("INR L") },
        0x2d => { disassemble_not_implemented() },
        0x2e => { disassemble_2("MVI L", byte_2) },
        0x2f => { disassemble_1("CMA") },
        0x30 => { disassemble_1("SIM") },
        0x31 => { disassemble_3("LXI SP", byte_2, byte_3) },
        0x32 => { disassemble_3("STA A", byte_2, byte_3) },
        0x33 => { disassemble_not_implemented() },
        0x34 => { disassemble_1("INR M") },
        0x35 => { disassemble_1("DCR M") },
        0x36 => { disassemble_2("MVI M", byte_2) },
        0x37 => { disassemble_1("STC") },
        0x38 => { disassemble_1("-") },
        0x39 => { disassemble_1("DAD SP") },
        0x3a => { disassemble_3("LDA A", byte_2, byte_3) },
        0x3b => { disassemble_not_implemented() },
        0x3c => { disassemble_1("INR A") },
        0x3d => { disassemble_1("DCR A") },
        0x3e => { disassemble_2("MVI A", byte_2) },
        0x3f => { disassemble_1("CMC") },
        0x40 => { disassemble_1("MOV B,B") },
        0x41 => { disassemble_1("MOV B,C") },
        0x42 => { disassemble_1("MOV B,D") },
        0x43 => { disassemble_1("MOV B,E") },
        0x44 => { disassemble_1("MOV B,H") },
        0x45 => { disassemble_1("MOV B,L") },
        0x46 => { disassemble_1("MOV B,F") },
        0x47 => { disassemble_1("MOV B,A") },
        0x48 => { disassemble_1("MOV C,B") },
        0x49 => { disassemble_1("MOV C,C") },
        0x4a => { disassemble_1("MOV C,D") },
        0x4b => { disassemble_1("MOV C,E") },
        0x4c => { disassemble_1("MOV C,H") },
        0x4d => { disassemble_1("MOV C,L") },
        0x4e => { disassemble_1("MOV C,M") },
        0x4f => { disassemble_1("MOV C,A") },
        0x50 => { disassemble_1("MOV D,B") },
        0x51 => { disassemble_1("MOV D,C") },
        0x52 => { disassemble_not_implemented() },
        0x53 => { disassemble_not_implemented() },
        0x54 => { disassemble_1("MOV D,H") },
        0x55 => { disassemble_not_implemented() },
        0x56 => { disassemble_1("MOV D,M") },
        0x57 => { disassemble_1("MOV D,A") },
        0x58 => { disassemble_not_implemented() },
        0x59 => { disassemble_1("MOV E,C") },
        0x5a => { disassemble_not_implemented() },
        0x5b => { disassemble_1("MOV E,E") },
        0x5c => { disassemble_not_implemented() },
        0x5d => { disassemble_not_implemented() },
        0x5e => { disassemble_1("MOV E,M") },
        0x5f => { disassemble_1("MOV E,A") },
        0x60 => { disassemble_1("MOV H,B") },
        0x61 => { disassemble_1("MOV H,C") },
        0x62 => { disassemble_1("MOV H,D") },
        0x63 => { disassemble_1("MOV H,E") },
        0x64 => { disassemble_1("MOV H,H") },
        0x65 => { disassemble_1("MOV H,L") },
        0x66 => { disassemble_1("MOV H,M") },
        0x67 => { disassemble_1("MOV H,A") },
        0x68 => { disassemble_1("MOV L,B") },
        0x69 => { disassemble_1("MOV L,C") },
        0x6a => { disassemble_not_implemented() },
        0x6b => { disassemble_not_implemented() },
        0x6c => { disassemble_1("MOV L,H") },
        0x6d => { disassemble_1("MOV L,L") },
        0x6e => { disassemble_1("MOV L,M") },
        0x6f => { disassemble_1("MOV L,A") },
        0x70 => { disassemble_1("MOV M,B") },
        0x71 => { disassemble_1("MOV M,C") },
        0x72 => { disassemble_1("MOV M,D") },
        0x73 => { disassemble_1("MOV M,E") },
        0x74 => { disassemble_1("MOV M,H") },
        0x75 => { disassemble_not_implemented() },
        0x76 => { disassemble_1("HLT") },
        0x77 => { disassemble_1("MOV M,A") },
        0x78 => { disassemble_1("MOV A,B") },
        0x79 => { disassemble_1("MOV A,C") },
        0x7a => { disassemble_1("MOV A,D") },
        0x7b => { disassemble_1("MOV A,E") },
        0x7c => { disassemble_1("MOV A,H") },
        0x7d => { disassemble_1("MOV A,L") },
        0x7e => { disassemble_1("MOV A,M") },
        0x7f => { disassemble_1("MOV A,A") },
        0x80 => { disassemble_1("ADD B") },
        0x81 => { disassemble_1("ADD C") },
        0x82 => { disassemble_1("ADD D") },
        0x83 => { disassemble_1("ADD E") },
        0x84 => { disassemble_1("ADD H") },
        0x85 => { disassemble_1("ADD L") },
        0x86 => { disassemble_1("ADD M") },
        0x87 => { disassemble_not_implemented() },
        0x88 => { disassemble_1("ADC B") },
        0x89 => { disassemble_not_implemented() },
        0x8a => { disassemble_1("ADC D") },
        0x8b => { disassemble_1("ADC E") },
        0x8c => { disassemble_not_implemented() },
        0x8d => { disassemble_not_implemented() },
        0x8e => { disassemble_1("ADC M") },
        0x8f => { disassemble_not_implemented() },
        0x90 => { disassemble_1("SUB B") },
        0x91 => { disassemble_not_implemented() },
        0x92 => { disassemble_not_implemented() },
        0x93 => { disassemble_not_implemented() },
        0x94 => { disassemble_1("SUB H") },
        0x95 => { disassemble_not_implemented() },
        0x96 => { disassemble_not_implemented() },
        0x97 => { disassemble_1("SUB A") },
        0x98 => { disassemble_1("SBB B") },
        0x99 => { disassemble_1("SBB C") },
        0x9a => { disassemble_1("SBB D") },
        0x9b => { disassemble_1("SBB E") },
        0x9c => { disassemble_not_implemented() },
        0x9d => { disassemble_1("SBB L") },
        0x9e => { disassemble_1("SBB M") },
        0x9f => { disassemble_not_implemented() },
        0xa0 => { disassemble_1("ANA B") },
        0xa1 => { disassemble_not_implemented() },
        0xa2 => { disassemble_not_implemented() },
        0xa3 => { disassemble_1("ANA E") },
        0xa4 => { disassemble_not_implemented() },
        0xa5 => { disassemble_not_implemented() },
        0xa6 => { disassemble_1("ANA M") },
        0xa7 => { disassemble_1("ANA A") },
        0xa8 => { disassemble_1("ANA B") },
        0xa9 => { disassemble_not_implemented() },
        0xaa => { disassemble_1("XRA D") },
        0xab => { disassemble_not_implemented() },
        0xac => { disassemble_not_implemented() },
        0xad => { disassemble_not_implemented() },
        0xae => { disassemble_not_implemented() },
        0xaf => { disassemble_1("XRA A") },
        0xb0 => { disassemble_1("ORA B") },
        0xb1 => { disassemble_not_implemented() },
        0xb2 => { disassemble_not_implemented() },
        0xb3 => { disassemble_1("ORA E") },
        0xb4 => { disassemble_1("ORA H") },
        0xb5 => { disassemble_not_implemented() },
        0xb6 => { disassemble_1("ORA M") },
        0xb7 => { disassemble_not_implemented() },
        0xb8 => { disassemble_1("CPM B") },
        0xb9 => { disassemble_not_implemented() },
        0xba => { disassemble_not_implemented() },
        0xbb => { disassemble_1("CMP E") },
        0xbc => { disassemble_1("CMP H") },
        0xbd => { disassemble_not_implemented() },
        0xbe => { disassemble_1("CMP M") },
        0xbf => { disassemble_not_implemented() },
        0xc0 => { disassemble_1("RNZ") },
        0xc1 => { disassemble_1("POP B") },
        0xc2 => { disassemble_3("JNZ", byte_2, byte_3) },
        0xc3 => { disassemble_3("JMP", byte_2, byte_3) },
        0xc4 => { disassemble_3("CNZ", byte_2, byte_3) },
        0xc5 => { disassemble_1("PUSH B") },
        0xc6 => { disassemble_2("ADI", byte_2) },
        0xc7 => { disassemble_not_implemented() },
        0xc8 => { disassemble_1("RZ") },
        0xc9 => { disassemble_1("RET") },
        0xca => { disassemble_3("JZ", byte_2, byte_3) },
        0xcb => { disassemble_not_implemented() },
        0xcc => { disassemble_3("CZ", byte_2, byte_3) },
        0xcd => { disassemble_3("CALL", byte_2, byte_3) },
        0xce => { disassemble_not_implemented() },
        0xcf => { disassemble_not_implemented() },
        0xd0 => { disassemble_1("RNC") },
        0xd1 => { disassemble_1("POP D") },
        0xd2 => { disassemble_3("JNC", byte_2, byte_3) },
        0xd3 => { disassemble_2("OUT", byte_2) },
        0xd4 => { disassemble_3("CNC", byte_2, byte_3) },
        0xd5 => { disassemble_1("PUSH D") },
        0xd6 => { disassemble_2("SUI", byte_2) },
        0xd7 => { disassemble_not_implemented() },
        0xd8 => { disassemble_1("RC") },
        0xd9 => { disassemble_not_implemented() },
        0xda => { disassemble_3("JC", byte_2, byte_3) },
        0xdb => { disassemble_2("IN", byte_2) },
        0xdc => { disassemble_not_implemented() },
        0xdd => { disassemble_not_implemented() },
        0xde => { disassemble_2("SBI", byte_2) },
        0xdf => { disassemble_not_implemented() },
        0xe0 => { disassemble_1("RPO") },
        0xe1 => { disassemble_1("POP H") },
        0xe2 => { disassemble_3("JPO", byte_2, byte_3) },
        0xe3 => { disassemble_1("XTHL") },
        0xe4 => { disassemble_not_implemented() },
        0xe5 => { disassemble_1("PUSH H") },
        0xe6 => { disassemble_2("ANI", byte_2) },
        0xe7 => { disassemble_not_implemented() },
        0xe8 => { disassemble_not_implemented() },
        0xe9 => { disassemble_1("PCHL") },
        0xea => { disassemble_not_implemented() },
        0xeb => { disassemble_1("XCHG") },
        0xec => { disassemble_3("CPE", byte_2, byte_3) },
        0xed => { disassemble_not_implemented() },
        0xee => { disassemble_2("XRI", byte_2) },
        0xef => { disassemble_not_implemented() },
        0xf0 => { disassemble_1("RP") },
        0xf1 => { disassemble_1("POP PSW") },
        0xf2 => { disassemble_not_implemented() },
        0xf3 => { disassemble_not_implemented() },
        0xf4 => { disassemble_not_implemented() },
        0xf5 => { disassemble_1("PUSH PSW") },
        0xf6 => { disassemble_2("ORI", byte_2) },
        0xf7 => { disassemble_not_implemented() },
        0xf8 => { disassemble_1("RM") },
        0xf9 => { disassemble_not_implemented() },
        0xfa => { disassemble_3("JM", byte_2, byte_3) },
        0xfb => { disassemble_1("EI") },
        0xfc => { disassemble_3("CM", byte_2, byte_3) },
        0xfd => { disassemble_not_implemented() },
        0xfe => { disassemble_2("CPI", byte_2) },
        0xff => { disassemble_1("RST 7") },
           _ => unreachable!()
    };

    op_bytes
}

fn read_16(buffer: &[u8; 0x10000], pc: usize) -> u16 {
    ((buffer[pc + 2] as u16) << 8) | (buffer[pc + 1] as u16)
}

fn not_implemented(state: &mut State, pc: u16) {
    println!("{:?}", state);
    disassemble(pc, &state);
    state.pc = 0;
}

fn step(mut state: State) -> State {
    let pc = state.pc as usize;
    let op_code = state.memory[pc];

    if state.pc == (0x10000 - 1) as u16 {
        println!("PC out of range.");
        state.pc = 0; return state
    }

    state.pc += 1;

    match op_code {
        0x00 => { },
        0x01 => not_implemented(&mut state, pc as u16),
        0x02 => not_implemented(&mut state, pc as u16),
        0x03 => not_implemented(&mut state, pc as u16),
        0x04 => not_implemented(&mut state, pc as u16),
        0x05 => not_implemented(&mut state, pc as u16),
        0x06 => {
            state.b = state.memory[pc + 1];
            state.pc += 1;
        },
        0x07 => not_implemented(&mut state, pc as u16),
        0x08 => not_implemented(&mut state, pc as u16),
        0x09 => not_implemented(&mut state, pc as u16),
        0x0a => not_implemented(&mut state, pc as u16),
        0x0b => not_implemented(&mut state, pc as u16),
        0x0c => not_implemented(&mut state, pc as u16),
        0x0d => not_implemented(&mut state, pc as u16),
        0x0e => not_implemented(&mut state, pc as u16),
        0x0f => not_implemented(&mut state, pc as u16),
        0x10 => not_implemented(&mut state, pc as u16),
        0x11 => not_implemented(&mut state, pc as u16),
        0x12 => not_implemented(&mut state, pc as u16),
        0x13 => not_implemented(&mut state, pc as u16),
        0x14 => not_implemented(&mut state, pc as u16),
        0x15 => not_implemented(&mut state, pc as u16),
        0x16 => not_implemented(&mut state, pc as u16),
        0x17 => not_implemented(&mut state, pc as u16),
        0x18 => not_implemented(&mut state, pc as u16),
        0x19 => not_implemented(&mut state, pc as u16),
        0x1a => not_implemented(&mut state, pc as u16),
        0x1b => not_implemented(&mut state, pc as u16),
        0x1c => not_implemented(&mut state, pc as u16),
        0x1d => not_implemented(&mut state, pc as u16),
        0x1e => not_implemented(&mut state, pc as u16),
        0x1f => not_implemented(&mut state, pc as u16),
        0x20 => not_implemented(&mut state, pc as u16),
        0x21 => not_implemented(&mut state, pc as u16),
        0x22 => not_implemented(&mut state, pc as u16),
        0x23 => not_implemented(&mut state, pc as u16),
        0x24 => not_implemented(&mut state, pc as u16),
        0x25 => not_implemented(&mut state, pc as u16),
        0x26 => not_implemented(&mut state, pc as u16),
        0x27 => not_implemented(&mut state, pc as u16),
        0x28 => not_implemented(&mut state, pc as u16),
        0x29 => not_implemented(&mut state, pc as u16),
        0x2a => not_implemented(&mut state, pc as u16),
        0x2b => not_implemented(&mut state, pc as u16),
        0x2c => not_implemented(&mut state, pc as u16),
        0x2d => not_implemented(&mut state, pc as u16),
        0x2e => not_implemented(&mut state, pc as u16),
        0x2f => not_implemented(&mut state, pc as u16),
        0x30 => not_implemented(&mut state, pc as u16),
        0x31 => {
            state.sp = read_16(&state.memory, pc as usize);
            state.pc += 2;
        },
        0x32 => not_implemented(&mut state, pc as u16),
        0x33 => not_implemented(&mut state, pc as u16),
        0x34 => not_implemented(&mut state, pc as u16),
        0x35 => not_implemented(&mut state, pc as u16),
        0x36 => not_implemented(&mut state, pc as u16),
        0x37 => not_implemented(&mut state, pc as u16),
        0x38 => not_implemented(&mut state, pc as u16),
        0x39 => not_implemented(&mut state, pc as u16),
        0x3a => not_implemented(&mut state, pc as u16),
        0x3b => not_implemented(&mut state, pc as u16),
        0x3c => not_implemented(&mut state, pc as u16),
        0x3d => not_implemented(&mut state, pc as u16),
        0x3e => not_implemented(&mut state, pc as u16),
        0x3f => not_implemented(&mut state, pc as u16),
        0x40 => not_implemented(&mut state, pc as u16),
        0x41 => not_implemented(&mut state, pc as u16),
        0x42 => not_implemented(&mut state, pc as u16),
        0x43 => not_implemented(&mut state, pc as u16),
        0x44 => not_implemented(&mut state, pc as u16),
        0x45 => not_implemented(&mut state, pc as u16),
        0x46 => not_implemented(&mut state, pc as u16),
        0x47 => not_implemented(&mut state, pc as u16),
        0x48 => not_implemented(&mut state, pc as u16),
        0x49 => not_implemented(&mut state, pc as u16),
        0x4a => not_implemented(&mut state, pc as u16),
        0x4b => not_implemented(&mut state, pc as u16),
        0x4c => not_implemented(&mut state, pc as u16),
        0x4d => not_implemented(&mut state, pc as u16),
        0x4e => not_implemented(&mut state, pc as u16),
        0x4f => not_implemented(&mut state, pc as u16),
        0x50 => not_implemented(&mut state, pc as u16),
        0x51 => not_implemented(&mut state, pc as u16),
        0x52 => not_implemented(&mut state, pc as u16),
        0x53 => not_implemented(&mut state, pc as u16),
        0x54 => not_implemented(&mut state, pc as u16),
        0x55 => not_implemented(&mut state, pc as u16),
        0x56 => not_implemented(&mut state, pc as u16),
        0x57 => not_implemented(&mut state, pc as u16),
        0x58 => not_implemented(&mut state, pc as u16),
        0x59 => not_implemented(&mut state, pc as u16),
        0x5a => not_implemented(&mut state, pc as u16),
        0x5b => not_implemented(&mut state, pc as u16),
        0x5c => not_implemented(&mut state, pc as u16),
        0x5d => not_implemented(&mut state, pc as u16),
        0x5e => not_implemented(&mut state, pc as u16),
        0x5f => not_implemented(&mut state, pc as u16),
        0x60 => not_implemented(&mut state, pc as u16),
        0x61 => not_implemented(&mut state, pc as u16),
        0x62 => not_implemented(&mut state, pc as u16),
        0x63 => not_implemented(&mut state, pc as u16),
        0x64 => not_implemented(&mut state, pc as u16),
        0x65 => not_implemented(&mut state, pc as u16),
        0x66 => not_implemented(&mut state, pc as u16),
        0x67 => not_implemented(&mut state, pc as u16),
        0x68 => not_implemented(&mut state, pc as u16),
        0x69 => not_implemented(&mut state, pc as u16),
        0x6a => not_implemented(&mut state, pc as u16),
        0x6b => not_implemented(&mut state, pc as u16),
        0x6c => not_implemented(&mut state, pc as u16),
        0x6d => not_implemented(&mut state, pc as u16),
        0x6e => not_implemented(&mut state, pc as u16),
        0x6f => not_implemented(&mut state, pc as u16),
        0x70 => not_implemented(&mut state, pc as u16),
        0x71 => not_implemented(&mut state, pc as u16),
        0x72 => not_implemented(&mut state, pc as u16),
        0x73 => not_implemented(&mut state, pc as u16),
        0x74 => not_implemented(&mut state, pc as u16),
        0x75 => not_implemented(&mut state, pc as u16),
        0x76 => not_implemented(&mut state, pc as u16),
        0x77 => not_implemented(&mut state, pc as u16),
        0x78 => not_implemented(&mut state, pc as u16),
        0x79 => not_implemented(&mut state, pc as u16),
        0x7a => not_implemented(&mut state, pc as u16),
        0x7b => not_implemented(&mut state, pc as u16),
        0x7c => not_implemented(&mut state, pc as u16),
        0x7d => not_implemented(&mut state, pc as u16),
        0x7e => not_implemented(&mut state, pc as u16),
        0x7f => not_implemented(&mut state, pc as u16),
        0x80 => not_implemented(&mut state, pc as u16),
        0x81 => not_implemented(&mut state, pc as u16),
        0x82 => not_implemented(&mut state, pc as u16),
        0x83 => not_implemented(&mut state, pc as u16),
        0x84 => not_implemented(&mut state, pc as u16),
        0x85 => not_implemented(&mut state, pc as u16),
        0x86 => not_implemented(&mut state, pc as u16),
        0x87 => not_implemented(&mut state, pc as u16),
        0x88 => not_implemented(&mut state, pc as u16),
        0x89 => not_implemented(&mut state, pc as u16),
        0x8a => not_implemented(&mut state, pc as u16),
        0x8b => not_implemented(&mut state, pc as u16),
        0x8c => not_implemented(&mut state, pc as u16),
        0x8d => not_implemented(&mut state, pc as u16),
        0x8e => not_implemented(&mut state, pc as u16),
        0x8f => not_implemented(&mut state, pc as u16),
        0x90 => not_implemented(&mut state, pc as u16),
        0x91 => not_implemented(&mut state, pc as u16),
        0x92 => not_implemented(&mut state, pc as u16),
        0x93 => not_implemented(&mut state, pc as u16),
        0x94 => not_implemented(&mut state, pc as u16),
        0x95 => not_implemented(&mut state, pc as u16),
        0x96 => not_implemented(&mut state, pc as u16),
        0x97 => not_implemented(&mut state, pc as u16),
        0x98 => not_implemented(&mut state, pc as u16),
        0x99 => not_implemented(&mut state, pc as u16),
        0x9a => not_implemented(&mut state, pc as u16),
        0x9b => not_implemented(&mut state, pc as u16),
        0x9c => not_implemented(&mut state, pc as u16),
        0x9d => not_implemented(&mut state, pc as u16),
        0x9e => not_implemented(&mut state, pc as u16),
        0x9f => not_implemented(&mut state, pc as u16),
        0xa0 => not_implemented(&mut state, pc as u16),
        0xa1 => not_implemented(&mut state, pc as u16),
        0xa2 => not_implemented(&mut state, pc as u16),
        0xa3 => not_implemented(&mut state, pc as u16),
        0xa4 => not_implemented(&mut state, pc as u16),
        0xa5 => not_implemented(&mut state, pc as u16),
        0xa6 => not_implemented(&mut state, pc as u16),
        0xa7 => not_implemented(&mut state, pc as u16),
        0xa8 => not_implemented(&mut state, pc as u16),
        0xa9 => not_implemented(&mut state, pc as u16),
        0xaa => not_implemented(&mut state, pc as u16),
        0xab => not_implemented(&mut state, pc as u16),
        0xac => not_implemented(&mut state, pc as u16),
        0xad => not_implemented(&mut state, pc as u16),
        0xae => not_implemented(&mut state, pc as u16),
        0xaf => not_implemented(&mut state, pc as u16),
        0xb0 => not_implemented(&mut state, pc as u16),
        0xb1 => not_implemented(&mut state, pc as u16),
        0xb2 => not_implemented(&mut state, pc as u16),
        0xb3 => not_implemented(&mut state, pc as u16),
        0xb4 => not_implemented(&mut state, pc as u16),
        0xb5 => not_implemented(&mut state, pc as u16),
        0xb6 => not_implemented(&mut state, pc as u16),
        0xb7 => not_implemented(&mut state, pc as u16),
        0xb8 => not_implemented(&mut state, pc as u16),
        0xb9 => not_implemented(&mut state, pc as u16),
        0xba => not_implemented(&mut state, pc as u16),
        0xbb => not_implemented(&mut state, pc as u16),
        0xbc => not_implemented(&mut state, pc as u16),
        0xbd => not_implemented(&mut state, pc as u16),
        0xbe => not_implemented(&mut state, pc as u16),
        0xbf => not_implemented(&mut state, pc as u16),
        0xc0 => not_implemented(&mut state, pc as u16),
        0xc1 => not_implemented(&mut state, pc as u16),
        0xc2 => not_implemented(&mut state, pc as u16),
        0xc3 => {
            state.pc = read_16(&state.memory, pc as usize);
        },
        0xc4 => not_implemented(&mut state, pc as u16),
        0xc5 => not_implemented(&mut state, pc as u16),
        0xc6 => not_implemented(&mut state, pc as u16),
        0xc7 => not_implemented(&mut state, pc as u16),
        0xc8 => not_implemented(&mut state, pc as u16),
        0xc9 => not_implemented(&mut state, pc as u16),
        0xca => not_implemented(&mut state, pc as u16),
        0xcb => not_implemented(&mut state, pc as u16),
        0xcc => not_implemented(&mut state, pc as u16),
        0xcd => not_implemented(&mut state, pc as u16),
        0xce => not_implemented(&mut state, pc as u16),
        0xcf => not_implemented(&mut state, pc as u16),
        0xd0 => not_implemented(&mut state, pc as u16),
        0xd1 => not_implemented(&mut state, pc as u16),
        0xd2 => not_implemented(&mut state, pc as u16),
        0xd3 => not_implemented(&mut state, pc as u16),
        0xd4 => not_implemented(&mut state, pc as u16),
        0xd5 => not_implemented(&mut state, pc as u16),
        0xd6 => not_implemented(&mut state, pc as u16),
        0xd7 => not_implemented(&mut state, pc as u16),
        0xd8 => not_implemented(&mut state, pc as u16),
        0xd9 => not_implemented(&mut state, pc as u16),
        0xda => not_implemented(&mut state, pc as u16),
        0xdb => not_implemented(&mut state, pc as u16),
        0xdc => not_implemented(&mut state, pc as u16),
        0xdd => not_implemented(&mut state, pc as u16),
        0xde => not_implemented(&mut state, pc as u16),
        0xdf => not_implemented(&mut state, pc as u16),
        0xe0 => not_implemented(&mut state, pc as u16),
        0xe1 => not_implemented(&mut state, pc as u16),
        0xe2 => not_implemented(&mut state, pc as u16),
        0xe3 => not_implemented(&mut state, pc as u16),
        0xe4 => not_implemented(&mut state, pc as u16),
        0xe5 => not_implemented(&mut state, pc as u16),
        0xe6 => not_implemented(&mut state, pc as u16),
        0xe7 => not_implemented(&mut state, pc as u16),
        0xe8 => not_implemented(&mut state, pc as u16),
        0xe9 => not_implemented(&mut state, pc as u16),
        0xea => not_implemented(&mut state, pc as u16),
        0xeb => not_implemented(&mut state, pc as u16),
        0xec => not_implemented(&mut state, pc as u16),
        0xed => not_implemented(&mut state, pc as u16),
        0xee => not_implemented(&mut state, pc as u16),
        0xef => not_implemented(&mut state, pc as u16),
        0xf0 => not_implemented(&mut state, pc as u16),
        0xf1 => not_implemented(&mut state, pc as u16),
        0xf2 => not_implemented(&mut state, pc as u16),
        0xf3 => not_implemented(&mut state, pc as u16),
        0xf4 => not_implemented(&mut state, pc as u16),
        0xf5 => not_implemented(&mut state, pc as u16),
        0xf6 => not_implemented(&mut state, pc as u16),
        0xf7 => not_implemented(&mut state, pc as u16),
        0xf8 => not_implemented(&mut state, pc as u16),
        0xf9 => not_implemented(&mut state, pc as u16),
        0xfa => not_implemented(&mut state, pc as u16),
        0xfb => not_implemented(&mut state, pc as u16),
        0xfc => not_implemented(&mut state, pc as u16),
        0xfd => not_implemented(&mut state, pc as u16),
        0xfe => not_implemented(&mut state, pc as u16),
        0xff => not_implemented(&mut state, pc as u16),
        _   => { state.pc = 0 },
    }

    state
}

fn main() -> std::io::Result<()> {
    let args: Vec<_> = env::args().collect();
    let mut file = File::open("invaders.rom")?;
    let mut state = State {
        b: 0,
        pc: 0,
        sp: 0,
        memory: ([0; 0x10000]),
    };

    let mut buffer = vec![];
    file.read_to_end(&mut buffer)?;

    let mut i = 0;
    while i < buffer.len() {
        state.memory[i] = buffer[i];
        i += 1
    }

    if args.get(1) == Some(&"disassemble".to_string()) {
        while state.pc < state.memory.len() as u16 {
            let op_bytes = disassemble(state.pc, &state);
            if op_bytes == 0 { break }
            state.pc += op_bytes;
        }
    } else {
        loop {
            state = step(state);
            if state.pc == 0 { break }
        }
    }

    Ok(())
}
